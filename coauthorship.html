<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- Yandex.Metrika counter -->
  <!-- /Yandex.Metrika counter -->
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="Kyrgyz NLP Co-Authorship Interactive Visualization"/>
  <title>KyrgyzNLP Co-Authorship Graph</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,300i,600"/>
  <link rel="stylesheet" href="/style.css"/>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml"/>
  <style>
        .node { stroke: #fff; stroke-width: 3px; }
        .link { stroke: #ccc; stroke-opacity: 0.3; }
        .node-label { font-size: 9px; fill: #777; pointer-events: none; }
        .link-label { font-size: 10px; fill: #999; pointer-events: none; opacity: 0.0;}
        .popup {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
            font-size: 14px;
        }
        #graph {
          width: 100%;
          height: 600px;
          border: 1px solid gray;
        }
        svg {
          width: 100%;
          height: 100%;
        }

        .export-button {
            padding: 10px 15px;
            margin: 10px;
            background-color: #BFD3E6;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .export-button:hover {
            background-color: #45a049;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
  <div class="container">
  <header class="masthead">
      <h1 class="masthead-title">
          <a href="">KyrgyzNLP Co-Authorship Graph</a>
      </h1>
      <nav class="masthead-nav">
          
      </nav>
  </header>
  <div class="content list">
      This is a webpage accompanying the talk <a href="/pdf/kyrgyz-nlp-slides_2024.pdf">KyrgyzNLP: Challenges, Progress, and Future</a> 
      given on October 18th, 2024 at the <a href="https://aistconf.org/">AIST-2024</a> conference.
      <br/><br/>
      Each node is the author, edges are papers. Scroll to zoom in/out, and drag the nodes with left click.
      <br/><br/>
      <div id="graph">
          <svg></svg>
      </div>
      <!-- Added the "Export to GEXF" button -->
      <button class="export-button" onclick="exportSVG()">Export as SVG</button>
      <button class="export-button" onclick="exportGEXF()">Export to GEXF</button>
      <button class="export-button" onclick="location.href='/'">Go Back</button>
      <div id="popup" class="popup"></div>
  </div>
  <script>
      // Define global variables
      let authorsIndex, bibliography, authorPositions;
      let nodes = {}, links = {};
      let normalizedPositions = {};
      // Declare nodeArray and linkArray globally
      let nodeArray = [], linkArray = [];

      // Load JSON files and initialize the graph
      function loadJSON(filename, callback) {
          fetch('static/' + filename)
              .then(response => response.json())
              .then(data => callback(data))
              .catch(error => console.error('Error loading JSON:', error));
      }

      // Function to normalize positions and initialize nodes
      function fetchAndInitializePositions() {
          nodeArray = Object.values(nodes);
          nodeArray.forEach(node => {
              if (normalizedPositions[node.id]) {
                  node.x = normalizedPositions[node.id].x;
                  node.y = normalizedPositions[node.id].y;
                  node.fx = normalizedPositions[node.id].x;
                  node.fy = normalizedPositions[node.id].y;
              }
          });

          // Release fixed positions after initialization
          setTimeout(() => {
              nodeArray.forEach(node => {
                  node.fx = null;
                  node.fy = null;
              });
          }, 100); // Release nodes after
      }

      // Load author positions and normalize them
      loadJSON('author_positions.json', data => {
          authorPositions = data;

          // Normalize positions
          const width = document.getElementById('graph').clientWidth;
          const height = document.getElementById('graph').clientHeight;

          const xValues = authorPositions.map(p => p.x);
          const yValues = authorPositions.map(p => p.y);

          const xMin = Math.min(...xValues);
          const xMax = Math.max(...xValues);
          const yMin = Math.min(...yValues);
          const yMax = Math.max(...yValues);

          authorPositions.forEach(pos => {
              normalizedPositions[pos.author_id] = {
                  x: ((pos.x - xMin) / (xMax - xMin)) * width,
                  y: ((pos.y - yMin) / (yMax - yMin)) * height
              };
          });

          // Load authors index and bibliography
          loadJSON('authors_index.json', data => {
              authorsIndex = data;
              loadJSON('bibliography_joined.json', visualizeGraph);
          });
      });

      // Visualize the graph after all data is loaded
      function visualizeGraph(bibliography) {
          // Construct nodes and links
          for (const [refKey, entry] of Object.entries(bibliography)) {
              const authorIDs = entry.author.split(' and ').map(s => s.trim());
              authorIDs.forEach(authorID => {
                  if (!nodes[authorID]) {
                      nodes[authorID] = { id: authorID, name_ru: authorsIndex[authorID]?.ru || authorID, name_en: authorsIndex[authorID]?.en || authorID, papers: 0 };
                  }
                  nodes[authorID].papers += 1;
              });
              for (let i = 0; i < authorIDs.length; i++) {
                  for (let j = i + 1; j < authorIDs.length; j++) {
                      const linkKey = authorIDs[i] + '-' + authorIDs[j];
                      if (!links[linkKey]) {
                          links[linkKey] = { source: authorIDs[i], target: authorIDs[j], label: refKey };
                      }
                  }
              }
          }

          // Initialize positions for nodes
          fetchAndInitializePositions();

          // Continue with D3 visualization
          nodeArray = Object.values(nodes);
          linkArray = Object.values(links);

          const width = document.getElementById('graph').clientWidth;
          const height = document.getElementById('graph').clientHeight;

          // Define color scale for nodes based on the number of papers
          const colorScale = d3.scaleLinear()
              .domain([1, d3.max(nodeArray, d => d.papers)])
              .range(["#BFD3E6", "#4A6FA5"]);

          const svg = d3.select("svg")
                        .attr("width", width).attr("height", height)
                        .call(d3.zoom().scaleExtent([0.5, 5]).on("zoom", (event) => {
                            svgGroup.attr("transform", event.transform);
                        }))
                        .attr("viewBox", [0, 0, width, height]);

          const svgGroup = svg.append("g");

          const link = svgGroup.append("g").selectAll("line")
                               .data(linkArray).enter().append("line")
                               .attr("class", "link");

          const linkLabel = svgGroup.append("g").selectAll("text")
                                     .data(linkArray).enter().append("text")
                                     .attr("class", "link-label")
                                     .attr("dy", ".0em")
                                     .text(d => d.label);

          // Adjust node radius based on the number of papers
          const maxPapers = d3.max(nodeArray, d => d.papers);
          const minRadius = 5, maxRadius = 15;
          const radiusScale = d3.scaleLinear()
                                .domain([1, maxPapers])
                                .range([minRadius, maxRadius]);

          const node = svgGroup.append("g").selectAll("circle")
                               .data(nodeArray).enter().append("circle")
                               .attr("class", "node")
                               .attr("r", d => radiusScale(d.papers))
                               .attr("fill", d => colorScale(d.papers))
                               .on("click", showPopup)
                               .call(d3.drag().on("start", dragstarted)
                                               .on("drag", dragged)
                                               .on("end", dragended));

          // Adjust font size based on node size
          const nodeLabel = svgGroup.append("g").selectAll("text")
                                    .data(nodeArray).enter().append("text")
                                    .attr("class", "node-label")
                                    .attr("dy", "-0.75em")
                                    .attr("text-anchor", "middle")
                                    .style("font-size", d => (radiusScale(d.papers) * 1.5) + "px")
                                    .text(d => d.name_en);

          // Define the tick function for simulation
          const simulation = d3.forceSimulation(nodeArray)
                               .force("link", d3.forceLink(linkArray).distance(50).id(d => d.id))
                               .force("charge", d3.forceManyBody().strength(-30))
                               .force("center", d3.forceCenter(width / 2, height / 2))
                               .force("collision", d3.forceCollide().radius(d => radiusScale(d.papers) + 5))
                               .on("tick", ticked);

          function ticked() {
              link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                  .attr("x2", d => d.target.x).attr("y2", d => d.target.y);

              linkLabel.attr("x", d => (d.source.x + d.target.x) / 2)
                       .attr("y", d => (d.source.y + d.target.y) / 2);

              node.attr("cx", d => d.x).attr("cy", d => d.y);
              nodeLabel.attr("x", d => d.x).attr("y", d => d.y);
          }

          function dragstarted(event, d) {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x; d.fy = d.y;
          }

          function dragged(event, d) { d.fx = event.x; d.fy = event.y; }

          function dragended(event, d) {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null; d.fy = null;
          }

          // Show popup on node click
          function showPopup(event, d) {
              const popup = document.getElementById('popup');
              popup.style.left = (event.pageX + 15) + 'px'; // Offset for better visibility
              popup.style.top = (event.pageY + 15) + 'px';
              popup.innerHTML = `<strong>Author:</strong><br>${d.name_ru} (${d.name_en})<br>Papers: ${d.papers}`;
              popup.style.display = 'block';
          }

          svg.on("click", () => {
              document.getElementById('popup').style.display = 'none';
          });
      }

      // Enhanced Export SVG function with inline styles and transformations
      function exportSVG() {
          const svgElement = document.querySelector("#graph svg");

          // Clone the original SVG element to modify it safely
          const svgClone = svgElement.cloneNode(true);

          // Get the current transform
          const transform = d3.zoomTransform(svgElement);

          // Apply the current transform to the clone
          svgClone.querySelector("g").setAttribute("transform", transform.toString());

          // Inline all styles
          inlineStyles(svgClone);

          // Remove any script elements (for security)
          const scripts = svgClone.querySelectorAll('script');
          scripts.forEach(script => script.remove());

          // Serialize the cloned SVG
          const serializer = new XMLSerializer();
          const source = serializer.serializeToString(svgClone);

          const svgBlob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
          const url = URL.createObjectURL(svgBlob);

          // Create a temporary download link and trigger the download
          const downloadLink = document.createElement("a");
          downloadLink.href = url;
          downloadLink.download = "kyrgyz-nlp-coauthorship-network.svg";
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          URL.revokeObjectURL(url);
      }

      // Function to inline computed styles
      function inlineStyles(element) {
          const allElements = element.querySelectorAll('*');
          allElements.forEach(el => {
              const computedStyle = window.getComputedStyle(el);
              let styleString = "";
              for (let i = 0; i < computedStyle.length; i++) {
                  const key = computedStyle[i];
                  const value = computedStyle.getPropertyValue(key);
                  styleString += `${key}:${value};`;
              }
              el.setAttribute("style", styleString);
          });
      }

      // Export to GEXF function
      function exportGEXF() {
          // Start building the GEXF string
          let gexf = `<?xml version="1.0" encoding="UTF-8"?>\n`;
          gexf += `<gexf xmlns="http://www.gexf.net/1.2draft" version="1.2">\n`;
          gexf += `  <graph mode="static" defaultedgetype="undirected">\n`;

          // Nodes
          gexf += `    <nodes>\n`;
          nodeArray.forEach(node => {
              gexf += `      <node id="${node.id}" label="${node.name_en}" />\n`;
          });
          gexf += `    </nodes>\n`;

          // Edges
          gexf += `    <edges>\n`;
          let edgeId = 0;
          linkArray.forEach(link => {
              gexf += `      <edge id="${edgeId}" source="${link.source}" target="${link.target}" />\n`;
              edgeId++;
          });
          gexf += `    </edges>\n`;

          gexf += `  </graph>\n`;
          gexf += `</gexf>\n`;

          // Create Blob and trigger download
          const blob = new Blob([gexf], { type: "application/gexf+xml" });
          const url = URL.createObjectURL(blob);
          const downloadLink = document.createElement("a");
          downloadLink.href = url;
          downloadLink.download = "kyrgyz-nlp-coauthorship-network.gexf";
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          URL.revokeObjectURL(url);
      }
  </script>
  </div>
</body>
</html>
